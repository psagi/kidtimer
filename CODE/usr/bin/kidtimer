#!/bin/bash
# Restrict kids computer access to specific hours and total time.
# By: Michael Groves - grover66_at_gmail_dot_com

#variables
#LANG="en_US.UTF-8" #unremark to change preferred language.
basedir="/usr/share/kidtimer"
dbdir="/var/local/kidtimer"
scheduledir="$dbdir/schedule"
timedir="$dbdir/time"
configdir="$dbdir"
Cdate=`/bin/date +%Y-%m-%d`
TUI=0
HOUR=`/bin/date +%H`
DOW=`/bin/date +%u`
WEEKEND="no"
[ "$DOW" == "6" ] && WEEKEND="sat"
[ "$DOW" == "7" ] && WEEKEND="sun"
[ ! -e $configdir/kid.list ] && touch $configdir/kid.list
[ ! -e $basedir/locale/$LANG ] && LANG="en_US.UTF-8"

#arguments
[ $# -eq 0 ] && TUI=1
[ $# -eq 1 ] && COMMAND=$1
[ $# -eq 2 ] && COMMAND=$1 && KID=$2
[ $# -eq 3 ] && COMMAND=$1 && KID=$2 && Time=$3

################# Subroutines ##################
################################################

get_info () {
echo "kidtimer info"
echo "---------------------------------------------"
/bin/date
echo "---"
echo "find $basedir/ -print | sort"
/usr/bin/find $basedir/ -print | /usr/bin/sort
echo "---"
echo "cat $configdir/kid.list"
/bin/cat $configdir/kid.list
echo "---"
echo "passwd -S -a"
/usr/bin/passwd -S -a
echo "---"
echo "cat $scheduledir/*"
/bin/cat $scheduledir/*
echo "---"
echo "cat $timedir/*"
/bin/cat $timedir/*
echo "---"
echo "cat /etc/cron.d/kidtimer"
/bin/cat /etc/cron.d/kidtimer
echo "---"
echo "apt-cache showpkg kidtimer"
/usr/bin/apt-cache showpkg kidtimer
echo "---"
echo "cat /etc/os-release"
/bin/cat /etc/os-release
echo "---"
echo "uname -a"
/bin/uname -a
echo "---"
echo "env"
/usr/bin/env
echo
}


has_ttl_been_touched_in_the_last_minute () {
	local p_username="$1"

	[ -e $(ttl_filename "$p_username") ] &&				\
		[							\
			$((						\
				$(date +%s) -				\
				$(stat -c "%Y" $(ttl_filename "$p_username") ) \
			)) -lt 59					\
		]
}


clean_up_logout_sequence () {
	local p_username="$1"

	/usr/bin/passwd "$p_username" -u
	go_clean_jobs "$p_username"
}


ttl_filename () {
	local p_username="$1"

	echo "$timedir/$p_username.ttl"
}


get_time_data () {
	local p_username="$1" p_field="$2"

	[ -e $(ttl_filename "$p_username") ] &&	\
		sed -n $(rownum "$p_field")p $(ttl_filename "$p_username")
}


get_ttl () {
	local p_username="$1"

	get_time_data "$p_username" ttl
}


rownum () {
	local p_fieldname="$1"

	case "$p_field" in
		ttl) echo 1 ;;
		reward) echo 2 ;;
		release_status) echo 3 ;;
		last_reset) echo 4 ;;
	esac
}


set_time_data () {
	local p_username="$1" p_data="$2" p_field="$3"

	local v_rownum=$(rownum "$p_field")
#echo "set_time_data(): v_rownum=$v_rownum" >&2
	if [ ! -e $(ttl_filename "$p_username") ]; then
		touch $(ttl_filename "$p_username")
	fi
#echo "set_time_data(): v_rownum=$v_rownum" >&2
	while [			\
		$(wc -l $(ttl_filename "$p_username") | cut -d " " -f 1) -lt \
		"$v_rownum"	\
	]; do echo >> $(ttl_filename "$p_username"); done
	sed -i "$v_rownum"$'c\\\n'"$p_data" $(ttl_filename "$p_username")
}

set_ttl () {
	local p_username="$1" p_ttl="$2"

	set_time_data "$p_username" "$p_ttl" ttl
}


set_reward () {
	local p_username="$1" p_reward="$2"

	set_time_data "$p_username" "$p_reward" reward
}


min () {
	local p_a="$1" p_b="$2"

	if [ "$p_a" -lt "$p_b" ]; then echo "$p_a"
	else echo "$p_b"
	fi
}


apply_penalty_if () {
	local p_username="$1" p_ttl="$2"

	local v_min_ttl_2_keep=10 v_reward v_penalty_2_apply
	if [ "$p_ttl" -gt "$v_min_ttl_2_keep" ]; then
		v_reward=$(get_reward "$p_username")
		if [ "$v_reward" -lt 0 ]; then
			v_penalty_2_apply=$(			\
				min				\
					$(( "$p_ttl" - "$v_min_ttl_2_keep" )) \
					$(( -"$v_reward" ))	\
			)
			p_ttl=$(("$p_ttl" - "$v_penalty_2_apply"))
			set_reward		\
				"$p_username"	\
				$(( "$v_reward" + "$v_penalty_2_apply" ))
		fi
	fi
	echo "$p_ttl"
}


apply_reward_if () {
	local p_username="$1" p_ttl="$2" p_low_ttl_threshold="$3"

	local v_reward_2_apply=0 v_reward
	if [ "$p_ttl" -le "$p_low_ttl_threshold" ]; then
		v_reward=$(get_reward "$p_username")
		if [ "$v_reward" -gt 0 ]; then
			v_reward_2_apply=$(				\
				min					\
					$((				\
						$p_low_ttl_threshold -	\
						$p_ttl + 1		\
					)) 				\
					"$v_reward"			\
				)
			set_reward		\
				"$p_username"	\
				$(( "$v_reward" - "$v_reward_2_apply" ))
		fi
	fi
	echo $(( "$p_ttl" + "$v_reward_2_apply" ))
}

is_released () {
	local p_username="$1"

	(								\
		[ "$(get_release_status $p_username)" == released ] ||	\
		[ "$(get_schedule $p_username)" == r ]			\
	)
}

go_check () {
local I v_low_ttl_threshold=5
for I in `/bin/cat $configdir/kid.list | sort -u`; do
	if has_ttl_been_touched_in_the_last_minute "$I"; then
#echo "go_check(): \$I = $I" 1>&2
		clean_up_logout_sequence "$I"
		go_hourly
	fi
        /usr/bin/users | /bin/grep -q $I
        if [ $? -eq 0 ] && ! is_released "$I"; then
#echo "go_check(): \$I = $I" 1>&2
		C=$(get_ttl "$I")
                if [ -n "$C" ]; then
                        C=$((C - 1))
                else
			C=$(get_ttl_time "$I")
                fi
		C=$(apply_penalty_if "$I" "$C")
		C=$(apply_reward_if "$I" "$C" "$v_low_ttl_threshold")
		set_ttl "$I" "$C"
		# check time
		if [ $C -le "$v_low_ttl_threshold" ]; then
        	        if [ ! -e /tmp/kidtimer.shutdown.$I ]; then
        	                /usr/bin/passwd $I -l
        	                go_logout $I
        	        fi
        	fi
        else
                go_clean_jobs $I
        fi
done
}


get_ttl_time () {
        [ "$WEEKEND" == "no" ] && /bin/cat $scheduledir/$1 | /bin/grep ^MAX | /usr/bin/awk '{ print $2 }'
        [ "$WEEKEND" == "sat" ] && /bin/cat $scheduledir/$1 | /bin/grep ^MAX | /usr/bin/awk '{ print $3 }'
        [ "$WEEKEND" == "sun" ] && /bin/cat $scheduledir/$1 |
		/bin/grep ^MAX | /usr/bin/awk '{ print ($4 != "" ? $4: $3) }'
}


go_clean_jobs () {
local K=$1 I
for I in `/usr/bin/atq | /usr/bin/awk '{ print $1 }' | /usr/bin/sort`; do
        /usr/bin/at -c $I | /bin/grep -q "bash.$K"
        [ $? -eq 0 ] && /usr/bin/at -d $I
done
[ -e /tmp/kidtimer.shutdown.$K ] && /bin/rm -rf /tmp/kidtimer.shutdown.$K
}


reset_time_data () {
	local p_username="$1" p_fieldname="$2"

	local v_default_time
	case "$p_fieldname" in
		ttl) v_default_time=$(get_ttl_time "$p_username") ;;
		reward) v_default_time=0 ;;
	esac
	set_time_data "$p_username" "$v_default_time" "$p_fieldname"
}


reset_ttl () {
	local p_username="$1"

	reset_time_data "$p_username" ttl
	set_time_data "$p_username" "$Cdate" last_reset
}


is_user_locked () {
	local p_username="$1"

	[							\
		"$(						\
			/usr/bin/passwd -S "$p_username" |	\
				/usr/bin/cut -d " " -f 2	\
		)" == L					\
	]
}


set_user_lock () {
	local p_username="$1" p_is_2B_locked="$2"
#echo "set_user_lock($p_username, $p_is_2B_locked)" >&2
	is_user_locked "$p_username"
	if [ "$?" != "$p_is_2B_locked" ]; then
		if [ "$p_is_2B_locked" == 0 ]; then
			/usr/bin/passwd "$p_username" -l
	                (				\
				/usr/bin/users | /bin/grep -q "$p_username" && \
				go_logout "$p_username"	\
			)
		else clean_up_logout_sequence "$p_username"
		fi
	fi
}


get_schedule () {
	local p_username="$1"

        if [ ! -e $scheduledir/$I ]; then
		echo y
		return
	fi
	/bin/grep "^$HOUR" "$scheduledir/$p_username" |
		/usr/bin/awk	\
			-v p_weekend="$WEEKEND"	-v p_day_of_week="$DOW" '
			{
				print (					\
					NF == 3 ?			\
					(p_weekend == "no" ? $2 : $3) :	\
					$(p_day_of_week + 1)		\
				);
			}'
}


go_daily () {
for I in `/bin/cat $configdir/kid.list | sort -u`; do
#        /usr/bin/stat -c %y $(ttl_filename "$I") | /bin/grep -q $Cdate
        get_last_reset "$I" | /bin/grep -q $Cdate
        if [ ! $? -eq 0 ]; then
		reset_ttl "$I"
		clear_released "$I"
        fi
done
go_hourly
}


go_hourly () {
if [ -s $configdir/kid.list ]; then
        for I in `/bin/cat $configdir/kid.list | sort -u`; do
		! is_released "$I" && ( 			\
			[ $(get_schedule "$I") == "n" ] ||	\
			[ $(get_ttl "$I") -le 0 ]		\
		)
		set_user_lock "$I" "$?"
	done
fi
}


go_logout () {
K=$1
go_send $K 5
go_send $K 4
go_send $K 3
go_send $K 2
go_send $K 1
go_killall $K
/usr/bin/touch /tmp/kidtimer.shutdown.$K
}


setup_job () {
	local p_delay="$1"

	# The whole magic is for cleaning up the stdout and stderr streams from
	# misdirected output
	local v_warning_line="warning: commands will be executed using /bin/sh"
	local v_job_line="^job [0-9]\+ at "
	/usr/bin/at now + "$p_delay" minutes 2> >(	\
		tee >(grep -v -e "$v_warning_line" -e "$v_job_line" >&2) | \
			grep "$v_job_line"		\
	)
}


go_send () {
K=$1
T=$2
LINE=$((7-$T))
TEXT=$((6-$T))
TMPFILE="/tmp/kidtimer.send$T.bash.$K"
/bin/rm -f $TMPFILE
echo "#!/bin/bash" > $TMPFILE
D=`/usr/bin/who | grep $K | grep -m1 "(:" | cut -d\( -f2 | sed s/\)// | sed s/://`
if [ -e $basedir/locale/$LANG ]; then
	MSG=`/bin/sed -n "$LINE"p $basedir/locale/$LANG`
else
	MSG="Your computer time will end in $TEXT minutes."
fi
echo "/bin/su $K -c 'DISPLAY=:$D /usr/bin/notify-send -i $basedir/icons/kidtimer-$TEXT.png \
	\"ALERT\" \"$MSG\"'" >> $TMPFILE
echo "/bin/rm -f $TMPFILE" >> $TMPFILE
echo "/bin/bash $TMPFILE" | setup_job "$T"
}


go_killall () {
K=$1
/bin/rm -f /tmp/killall.bash.$K
echo "#!/bin/bash" > /tmp/killall.bash.$K
echo "/usr/bin/pkill -KILL -u $K" >> /tmp/killall.bash.$K
echo "/bin/rm -rf /tmp/kidtimer.shutdown.$K" >> /tmp/killall.bash.$K
echo "/bin/rm -f /tmp/killall.bash.$K" >> /tmp/killall.bash.$K
echo "/bin/bash /tmp/killall.bash.$K" | setup_job 6
}


go_echo_error () {
echo "`/bin/sed -n '12p' $basedir/locale/$LANG`"
}


go_echo_done () {
echo "`/bin/sed -n '13p' $basedir/locale/$LANG`"
}


go_reset_time () {
	local p_username="$1"

	reset_ttl "$p_username"
	go_echo_done
}


go_addtime () {
	local v_username="$KID" v_time="$Time"

	increase_time_field "$v_username" "$v_time" ttl
}


addreward () {
	local v_username="$KID" v_time="$Time"

	increase_time_field "$v_username" "$v_time" reward
}


increase_time_field () {
local U="$1" A="$2" p_field="$3"
grep -q $U $configdir/kid.list
if [ $? -eq 0 ]; then 
	if [ "$A" == "reset" ]; then
		reset_time_data "$U" "$p_field"
	elif [ "$A" == "" ]; then
	        go_echo_error
		case "$p_field" in
			ttl)
				#english: Syntax: addtime <user> <minutes|reset>
				echo "`/bin/sed -n '22p' $basedir/locale/$LANG`"
			;;
			reward)
				#english:
				# Syntax: addreward <user> <minutes|reset>
				echo "`/bin/sed -n '23p' $basedir/locale/$LANG`"
			;;
		esac
	        exit 1
	else        
		set_time_data	\
			"$U" $(( $(get_time_data "$U" "$p_field") + A )) \
			"$p_field"
	fi
	get_time
else
	go_echo_error
	#english: User not setup.
	echo "`/bin/sed -n '19p' $basedir/locale/$LANG`"
	exit 1
fi
}


get_reward () {
	local p_username="$1"

	get_time_data "$p_username" reward
}


get_release_status () {
	local p_username="$1"

	get_time_data "$p_username" release_status
}

get_last_reset () {
	local p_username="$1"

	get_time_data "$p_username" last_reset
}


get_time () {
local v_ttl=$(get_ttl "$KID")
if [ -n "$v_ttl" ]; then
	echo "$v_ttl "$(get_reward "$KID")" "$(get_release_status "$KID")
else
	echo
	#english: User not setup.
	echo "`/bin/sed -n '19p' $basedir/locale/$LANG`"
	echo
fi
}


go_tui () {
go_command_list
echo -n "Choose: "; read X
case "$X" in
1) go_setup_user
        ;;
2) go_modify_user
        ;;
3) go_remove_user
        ;;
4) go_list_users
        ;;
5) exit 0
        ;;
esac
go_tui
}


go_command_list () {
echo
echo "1) "`/bin/sed -n '7p' $basedir/locale/$LANG`
echo "2) "`/bin/sed -n '8p' $basedir/locale/$LANG`
echo "3) "`/bin/sed -n '9p' $basedir/locale/$LANG`
echo "4) "`/bin/sed -n '10p' $basedir/locale/$LANG`
echo "5) "`/bin/sed -n '11p' $basedir/locale/$LANG`
echo
}


go_list_users () {
echo
#english: Users configured for kidtimer:
echo "`/bin/sed -n '14p' $basedir/locale/$LANG`"
if [ -s $configdir/kid.list ]; then
        /bin/cat $configdir/kid.list
else
	#english: No configured users.
        echo "`/bin/sed -n '15p' $basedir/locale/$LANG`"
	echo
fi
}

go_setup_user () {
echo
#english: Username:
echo -n "`/bin/sed -n '16p' $basedir/locale/$LANG` "; read U
/usr/bin/id $U > /dev/null 2>&1
if [ $? -eq 0 ]; then
        /bin/cp $scheduledir/blank $scheduledir/$U
        echo $U >> $configdir/kid.list
	go_reset_time "$U"
        echo
	#english: Modify limits now ?(y/n):
        echo -n "`/bin/sed -n '17p' $basedir/locale/$LANG`"; read M
        if [ "$M" == "y" ]; then
                if [ -e /usr/bin/nano ]; then
                	/usr/bin/nano $scheduledir/$U
         	else
                	/usr/bin/vi $scheduledir/$U
                fi
		go_reset_time "$U"
        fi
else
	go_echo_error
	#english: User does not exist. Please create user using the useradd command first.
        echo "`/bin/sed -n '18p' $basedir/locale/$LANG`"
fi
}


go_modify_user () {
echo
#english: Username:
echo -n "`/bin/sed -n '16p' $basedir/locale/$LANG` "; read U
grep -q ^$U $configdir/kid.list
if [ $? -eq 0 ]; then
        if [ -e /usr/bin/nano ]; then
                /usr/bin/nano $scheduledir/$U
                go_echo_done
        else
                /usr/bin/vi $scheduledir/$U
                go_echo_done
        fi
else
	go_echo_error
	#english: User not setup.
        echo "`/bin/sed -n '19p' $basedir/locale/$LANG`"
	echo
fi
}


go_remove_user () {
echo
#english: Username:
echo -n "`/bin/sed -n '16p' $basedir/locale/$LANG` "; read U
grep -q ^$U $configdir/kid.list
if [ $? -eq 0 ]; then
        /bin/grep -v ^$U $configdir/kid.list > /tmp/kidtimer.tmp
        /bin/cat /tmp/kidtimer.tmp > $configdir/kid.list
        go_echo_done
else
	go_echo_error
	#english: User not setup.
        echo "`/bin/sed -n '19p' $basedir/locale/$LANG`"
	echo
fi
}


go_help () {
echo
echo "Commands:"
echo "--------------------------------------------------------------------------------"
echo "addtime <user> <minutes> ... Increases allowed time for the day."
echo "addreward <user> <minutes> ... Increases persistent reward balance."
echo "release <user> ... Suspends time control without touching daily time and"
echo "	reward balance"
echo "control <user> ... Resumes time control"
echo "gettime <user> ... Prints remaining time for the day."
echo "reset <user> ... Reset time for the day."
echo "logout <user> ... Starts logout sequence for user."
echo "hourly ... Enables/disables user access based on the schedule."
echo "daily ... Resets time for the new day."
#echo "update ... Updates kidtimer to the latest version."
echo "info ... Gather local configurations to troubleshoot issues."
echo "help ... This list."
echo "--------------------------------------------------------------------------------"
}

#check_dependencies () {
##at
#P1="";P2="";P3="";pstatus="0"
#/usr/bin/dpkg -s at >/dev/null 2>/dev/null
#if [ ! $? -eq 0 ]; then
#	P1="at"
#	pstatus=1
#fi
##libnotify-bin
#/usr/bin/dpkg -s libnotify-bin >/dev/null 2>/dev/null
#if [ ! $? -eq 0 ]; then
#        P2="libnotify-bin"
#        pstatus=1
#fi
##bsdutils
#/usr/bin/dpkg -s bsdutils >/dev/null 2>/dev/null
#if [ ! $? -eq 0 ]; then
#        P3="bsdutils"
#        pstatus=1
#fi
#if [ "$pstatus" == "1" ]; then
#	echo
#	#english: Error. Missing package dependencies.
#	echo "`/bin/sed -n '20p' $basedir/locale/$LANG`"
#	#english: Please install using the following line;
#	echo "`/bin/sed -n '21p' $basedir/locale/$LANG`"
#	echo "sudo apt-get install "$P1" "$P2" "$P3
#	exit 1
#fi
#}

#get_update () {
#URL='https://github.com/grover66/kidtimer/raw/master/DEBS/kidtimer_latest.deb'
#if [ -e /usr/bin/wget ]; then
#/usr/bin/wget "$URL" -qO /tmp/kidtimer_latest.deb
#/usr/bin/dpkg -i /tmp/kidtimer_latest.deb
#/bin/rm -f /tmp/kidtimer_latest.deb
#else
#echo
#echo "Error. Requires wget"
#echo "To install wget; sudo apt-get install wget"
#fi
#}

set_released () {
	local p_username="$1"

	set_time_data "$p_username" "released" release_status
}


clear_released () {
	local p_username="$1"

	set_time_data "$p_username" "" release_status
}


release () {
	local p_username="$1"

	set_released "$p_username"
	go_echo_done
}


control () {
	local p_username="$1"

	clear_released "$p_username"
	go_echo_done
}


###################### Code ####################
################################################

if [ $TUI -eq 1 ]; then
	go_tui
fi

case "$COMMAND" in
addtime) go_addtime
        ;;
addreward) addreward
        ;;
release) release "$KID"
        ;;
control) control "$KID"
        ;;
reset) go_reset_time "$KID"
        ;;
gettime) get_time
        ;;
logout) go_logout $KID
        ;;
hourly) go_hourly
        ;;
daily) go_daily
        ;;
#update) get_update
#;;
check) go_check
        ;;
info) get_info
        ;;
-h) go_help
        ;;
help) go_help
        ;;
*)
	go_echo_error
	go_help
        ;;
esac
exit 0
